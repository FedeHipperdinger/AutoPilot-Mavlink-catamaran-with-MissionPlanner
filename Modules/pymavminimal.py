'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ardupilotmega.xml,common.xml,uAvionix.xml,icarous.xml

Note: this file has been auto-generated. DO NOT EDIT
'''
import struct, array, time, json, os, sys

from mavcrc import x25crc

WIRE_PROTOCOL_VERSION = '2.0'

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == '2.0' and not force_mavlink1:
            return struct.pack('<BBBBBBBHB', 253, self.mlen,
                               self.incompat_flags, self.compat_flags,
                               self.seq, self.srcSystem, self.srcComponent,
                               self.msgId&0xFFFF, self.msgId>>16)
        return struct.pack('<BBBBBB', PROTOCOL_MARKER_V1, self.mlen, self.seq,
                           self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name
        self._signed     = False
        self._link_id    = None
        self._instances  = None
        self._instance_field = None

    # swiped from DFReader.py
    def to_string(self, s):
        '''desperate attempt to convert a string regardless of what garbage we get'''
        try:
            return s.decode("utf-8")
        except Exception as e:
            pass
        try:
            s2 = s.encode('utf-8', 'ignore')
            x = u"%s" % s2
            return s2
        except Exception:
            pass
        # so its a nasty one. Let's grab as many characters as we can
        r = ''
        while s != '':
            try:
                r2 = r + s[0]
                s = s[1:]
                r2 = r2.encode('ascii', 'ignore')
                x = u"%s" % r2
                r = r2
            except Exception:
                break
        return r + '_XXX'

    def format_attr(self, field):
        '''override field getter'''
        raw_attr = getattr(self,field)
        if isinstance(raw_attr, bytes):
            raw_attr = self.to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != '1.0' and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred') is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen-1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        self._header  = MAVLink_header(self._header.msgId,
                                       incompat_flags=incompat_flags, compat_flags=0,
                                       mlen=len(self._payload), seq=mav.seq,
                                       srcSystem=mav.srcSystem, srcComponent=mav.srcComponent)
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(struct.pack('B', crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf

    def __getitem__(self, key):
        '''support indexing, allowing for multi-instance sensors in one message'''
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_AHRS = 163
MAVLINK_MSG_ID_DATA16 = 169
MAVLINK_MSG_ID_DATA32 = 170
MAVLINK_MSG_ID_DATA64 = 171
MAVLINK_MSG_ID_DATA96 = 172
MAVLINK_MSG_ID_HEARTBEAT = 0
MAVLINK_MSG_ID_SYS_STATUS = 1
MAVLINK_MSG_ID_SYSTEM_TIME = 2
MAVLINK_MSG_ID_GPS_RAW_INT = 24
MAVLINK_MSG_ID_ATTITUDE = 30
MAVLINK_MSG_ID_VFR_HUD = 74
MAVLINK_MSG_ID_COMMAND_INT = 75
MAVLINK_MSG_ID_COMMAND_LONG = 76
MAVLINK_MSG_ID_COMMAND_ACK = 77
MAVLINK_MSG_ID_NAMED_VALUE_FLOAT = 251
MAVLINK_MSG_ID_NAMED_VALUE_INT = 252
MAVLINK_MSG_ID_STATUSTEXT = 253
MAVLINK_MSG_ID_SCALED_IMU = 26

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            super().__init__(msg)
            self.message = msg

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
                self._instance_field = None

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, srcSystem=0, srcComponent=0):
                self.seq = 0
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.buf_index = 0
                self.expected_length = HEADER_LEN_V1+2
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 253
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                #self.mav20_unpacker = struct.Struct('<cBBBBBBHB')
                #self.mav10_unpacker = struct.Struct('<cBBBBB')
                #self.mav20_h3_unpacker = struct.Struct('BBB')
                #self.mav_csum_unpacker = struct.Struct('<H')
                #self.mav_sign_unpacker = struct.Struct('<IH')

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg, force_mavlink1=False):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def buf_len(self):
            return len(self.buf) - self.buf_index

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            ret = self.expected_length - self.buf_len()

            if ret <= 0:
                return 1
            return ret

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            m = self.__parse_char_legacy()

            if m is not None:
                self.total_packets_received += 1
                self.__callbacks(m)
            else:
                # XXX The idea here is if we've read something and there's nothing left in
                # the buffer, reset it to 0 which frees the memory
                if self.buf_len() == 0 and self.buf_index != 0:
                    self.buf = bytearray()
                    self.buf_index = 0

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            header_len = HEADER_LEN_V1
            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
                header_len = HEADER_LEN_V2

            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
                magic = self.buf[self.buf_index]
                self.buf_index += 1
                if self.robust_parsing:
                    m = MAVLink_bad_data(bytearray([magic]), 'Bad prefix')
                    self.expected_length = header_len+2
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if self.buf_len() >= 3:
                sbuf = self.buf[self.buf_index:3+self.buf_index]
                #if sys.version_info.major < 3:
                #    sbuf = str(sbuf)
                (magic, self.expected_length, incompat_flags) = struct.unpack('BBB', sbuf)
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
                self.expected_length += header_len + 2
            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:
                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])
                self.buf_index += self.expected_length
                self.expected_length = header_len+2
                if self.robust_parsing:
                    try:
                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        # swiped from DFReader.py
        def to_string(self, s):
            '''desperate attempt to convert a string regardless of what garbage we get'''
            try:
                return s.decode("utf-8")
            except Exception as e:
                pass
            try:
                s2 = s.encode('utf-8', 'ignore')
                x = u"%s" % s2
                return s2
            except Exception:
                pass
            # so its a nasty one. Let's grab as many characters as we can
            r = ''
            while s != '':
                try:
                    r2 = r + s[0]
                    s = s[1:]
                    r2 = r2.encode('ascii', 'ignore')
                    x = u"%s" % r2
                    r = r2
                except Exception:
                    break
            return r + '_XXX'

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                if msgbuf[0] != PROTOCOL_MARKER_V1:
                    headerlen = 10
                    try:
                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = struct.unpack('<sBBBBBBHB', msgbuf[:headerlen])
                    except Exception as emsg:
                        print(msgbuf[:headerlen])
                        raise MAVError('Unable to unpack MAVLink2 header: %s' % emsg)
                    msgId = msgIdlow | (msgIdhigh<<16)
                    mapkey = msgId
                else:
                    headerlen = 6
                    try:
                        magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('<sBBBBB', msgbuf[:headerlen])
                        incompat_flags = 0
                        compat_flags = 0
                    except Exception as emsg:
                        raise MAVError('Unable to unpack MAVLink1 header: %s' % emsg)
                    mapkey = msgId
                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
                else:
                    signature_len = 0

                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-(headerlen+2+signature_len):
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))

                if not mapkey in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))

                # decode the payload
                type = mavlink_map[mapkey]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = struct.unpack('<H', msgbuf[-(2+signature_len):][:2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-(2+signature_len)]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                csize = struct.calcsize(type.unpacker)
                mbuf = bytearray(msgbuf[headerlen:-(2+signature_len)])
                if len(mbuf) < csize:
                    # zero pad to give right size
                    mbuf.extend(bytearray([0]*(csize - len(mbuf))))
                if len(mbuf) < csize:
                    raise MAVError('Bad message of type %s length %u needs %s' % (
                        type, len(mbuf), csize))
                mbuf = mbuf[:csize]
                try:
                    t = struct.unpack(type.unpacker, mbuf)
                except Exception as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(mbuf), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if type.fieldtypes[i] == 'char':
                        tlist[i] = self.to_string(tlist[i])
                        j = tlist[i].find(chr(0))
                        if j != -1:
                            tlist[i] = tlist[i][0:j]
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-(2+signature_len)]
                m._crc = crc
                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
                return m
                
        def named_value_float_encode(self, time_boot_ms, name, value):
                '''
                Send a key-value pair as float. The use of this message is discouraged
                for normal packets, but a quite efficient way for
                testing new messages and getting experimental debug
                output.

                time_boot_ms              : Timestamp (time since system boot). [ms] (type:uint32_t)
                name                      : Name of the debug variable (type:char)
                value                     : Floating point value (type:float)

                '''
                return MAVLink_named_value_float_message(time_boot_ms, name, value)

        def named_value_float_send(self, time_boot_ms, name, value, force_mavlink1=False):
                '''
                Send a key-value pair as float. The use of this message is discouraged
                for normal packets, but a quite efficient way for
                testing new messages and getting experimental debug
                output.

                time_boot_ms              : Timestamp (time since system boot). [ms] (type:uint32_t)
                name                      : Name of the debug variable (type:char)
                value                     : Floating point value (type:float)

                '''
                return self.send(self.named_value_float_encode(time_boot_ms, name, value), force_mavlink1=force_mavlink1)

        def heartbeat_encode(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version=3):
                '''
                The heartbeat message shows that a system or component is present and
                responding. The type and autopilot fields (along with
                the message component id), allow the receiving system
                to treat further messages from this system
                appropriately (e.g. by laying out the user interface
                based on the autopilot). This microservice is
                documented at
                https://mavlink.io/en/services/heartbeat.html

                type                      : Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type. (type:uint8_t, values:MAV_TYPE)
                autopilot                 : Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers. (type:uint8_t, values:MAV_AUTOPILOT)
                base_mode                 : System mode bitmap. (type:uint8_t, values:MAV_MODE_FLAG)
                custom_mode               : A bitfield for use for autopilot-specific flags (type:uint32_t)
                system_status             : System status flag. (type:uint8_t, values:MAV_STATE)
                mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (type:uint8_t)

                '''
                return MAVLink_heartbeat_message(type, autopilot, base_mode, custom_mode, system_status, mavlink_version)

        def heartbeat_send(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version=3, force_mavlink1=False):
                '''
                The heartbeat message shows that a system or component is present and
                responding. The type and autopilot fields (along with
                the message component id), allow the receiving system
                to treat further messages from this system
                appropriately (e.g. by laying out the user interface
                based on the autopilot). This microservice is
                documented at
                https://mavlink.io/en/services/heartbeat.html

                type                      : Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type. (type:uint8_t, values:MAV_TYPE)
                autopilot                 : Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers. (type:uint8_t, values:MAV_AUTOPILOT)
                base_mode                 : System mode bitmap. (type:uint8_t, values:MAV_MODE_FLAG)
                custom_mode               : A bitfield for use for autopilot-specific flags (type:uint32_t)
                system_status             : System status flag. (type:uint8_t, values:MAV_STATE)
                mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (type:uint8_t)

                '''
                return self.send(self.heartbeat_encode(type, autopilot, base_mode, custom_mode, system_status, mavlink_version), force_mavlink1=force_mavlink1)
                
class MAVLink_named_value_float_message(MAVLink_message):
        '''
        Send a key-value pair as float. The use of this message is
        discouraged for normal packets, but a quite efficient way for
        testing new messages and getting experimental debug output.
        '''
        id = MAVLINK_MSG_ID_NAMED_VALUE_FLOAT
        name = 'NAMED_VALUE_FLOAT'
        fieldnames = ['time_boot_ms', 'name', 'value']
        ordered_fieldnames = ['time_boot_ms', 'value', 'name']
        fieldtypes = ['uint32_t', 'char', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"time_boot_ms": "ms"}
        format = '<If10s'
        native_format = bytearray('<Ifc', 'ascii')
        orders = [0, 2, 1]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 10]
        crc_extra = 170
        unpacker = '<If10s'
        instance_field = 'name'
        instance_offset = 8

        def __init__(self, time_boot_ms, name, value):
                MAVLink_message.__init__(self, MAVLink_named_value_float_message.id, MAVLink_named_value_float_message.name)
                self._fieldnames = MAVLink_named_value_float_message.fieldnames
                self._instance_field = MAVLink_named_value_float_message.instance_field
                self._instance_offset = MAVLink_named_value_float_message.instance_offset
                self.time_boot_ms = time_boot_ms
                self.name = name
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 170, struct.pack('<If10s', self.time_boot_ms, self.value, self.name), force_mavlink1=force_mavlink1)

class MAVLink_named_value_int_message(MAVLink_message):
        '''
        Send a key-value pair as integer. The use of this message is
        discouraged for normal packets, but a quite efficient way for
        testing new messages and getting experimental debug output.
        '''
        id = MAVLINK_MSG_ID_NAMED_VALUE_INT
        name = 'NAMED_VALUE_INT'
        fieldnames = ['time_boot_ms', 'name', 'value']
        ordered_fieldnames = ['time_boot_ms', 'value', 'name']
        fieldtypes = ['uint32_t', 'char', 'int32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"time_boot_ms": "ms"}
        format = '<Ii10s'
        native_format = bytearray('<Iic', 'ascii')
        orders = [0, 2, 1]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 10]
        crc_extra = 44
        unpacker = '<Ii10s'
        instance_field = 'name'
        instance_offset = 8

        def __init__(self, time_boot_ms, name, value):
                MAVLink_message.__init__(self, MAVLink_named_value_int_message.id, MAVLink_named_value_int_message.name)
                self._fieldnames = MAVLink_named_value_int_message.fieldnames
                self._instance_field = MAVLink_named_value_int_message.instance_field
                self._instance_offset = MAVLink_named_value_int_message.instance_offset
                self.time_boot_ms = time_boot_ms
                self.name = name
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 44, struct.pack('<Ii10s', self.time_boot_ms, self.value, self.name), force_mavlink1=force_mavlink1)

class MAVLink_statustext_message(MAVLink_message):
        '''
        Status text message. These messages are printed in yellow in
        the COMM console of QGroundControl. WARNING: They consume
        quite some bandwidth, so use only for important status and
        error messages. If implemented wisely, these messages are
        buffered on the MCU and sent only at a limited rate (e.g. 10
        Hz).
        '''
        id = MAVLINK_MSG_ID_STATUSTEXT
        name = 'STATUSTEXT'
        fieldnames = ['severity', 'text', 'id', 'chunk_seq']
        ordered_fieldnames = ['severity', 'text', 'id', 'chunk_seq']
        fieldtypes = ['uint8_t', 'char', 'uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"severity": "MAV_SEVERITY"}
        fieldunits_by_name = {}
        format = '<B50sHB'
        native_format = bytearray('<BcHB', 'ascii')
        orders = [0, 1, 2, 3]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 50, 0, 0]
        crc_extra = 83
        unpacker = '<B50sHB'
        instance_field = None
        instance_offset = -1

        def __init__(self, severity, text, id=0, chunk_seq=0):
                MAVLink_message.__init__(self, MAVLink_statustext_message.id, MAVLink_statustext_message.name)
                self._fieldnames = MAVLink_statustext_message.fieldnames
                self._instance_field = MAVLink_statustext_message.instance_field
                self._instance_offset = MAVLink_statustext_message.instance_offset
                self.severity = severity
                self.text = text
                self.id = id
                self.chunk_seq = chunk_seq

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 83, struct.pack('<B50sHB', self.severity, self.text, self.id, self.chunk_seq), force_mavlink1=force_mavlink1)
                
class MAVLink_command_int_message(MAVLink_message):
        '''
        Message encoding a command with parameters as scaled integers.
        Scaling depends on the actual command value. The command
        microservice is documented at
        https://mavlink.io/en/services/command.html
        '''
        id = MAVLINK_MSG_ID_COMMAND_INT
        name = 'COMMAND_INT'
        fieldnames = ['target_system', 'target_component', 'frame', 'command', 'current', 'autocontinue', 'param1', 'param2', 'param3', 'param4', 'x', 'y', 'z']
        ordered_fieldnames = ['param1', 'param2', 'param3', 'param4', 'x', 'y', 'z', 'command', 'target_system', 'target_component', 'frame', 'current', 'autocontinue']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint16_t', 'uint8_t', 'uint8_t', 'float', 'float', 'float', 'float', 'int32_t', 'int32_t', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"frame": "MAV_FRAME", "command": "MAV_CMD"}
        fieldunits_by_name = {}
        format = '<ffffiifHBBBBB'
        native_format = bytearray('<ffffiifHBBBBB', 'ascii')
        orders = [8, 9, 10, 7, 11, 12, 0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 158
        unpacker = '<ffffiifHBBBBB'
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z):
                MAVLink_message.__init__(self, MAVLink_command_int_message.id, MAVLink_command_int_message.name)
                self._fieldnames = MAVLink_command_int_message.fieldnames
                self._instance_field = MAVLink_command_int_message.instance_field
                self._instance_offset = MAVLink_command_int_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.frame = frame
                self.command = command
                self.current = current
                self.autocontinue = autocontinue
                self.param1 = param1
                self.param2 = param2
                self.param3 = param3
                self.param4 = param4
                self.x = x
                self.y = y
                self.z = z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 158, struct.pack('<ffffiifHBBBBB', self.param1, self.param2, self.param3, self.param4, self.x, self.y, self.z, self.command, self.target_system, self.target_component, self.frame, self.current, self.autocontinue), force_mavlink1=force_mavlink1)

class MAVLink_command_long_message(MAVLink_message):
        '''
        Send a command with up to seven parameters to the MAV. The
        command microservice is documented at
        https://mavlink.io/en/services/command.html
        '''
        id = MAVLINK_MSG_ID_COMMAND_LONG
        name = 'COMMAND_LONG'
        fieldnames = ['target_system', 'target_component', 'command', 'confirmation', 'param1', 'param2', 'param3', 'param4', 'param5', 'param6', 'param7']
        ordered_fieldnames = ['param1', 'param2', 'param3', 'param4', 'param5', 'param6', 'param7', 'command', 'target_system', 'target_component', 'confirmation']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint16_t', 'uint8_t', 'float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"command": "MAV_CMD"}
        fieldunits_by_name = {}
        format = '<fffffffHBBB'
        native_format = bytearray('<fffffffHBBB', 'ascii')
        orders = [8, 9, 7, 10, 0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 152
        unpacker = '<fffffffHBBB'
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7):
                MAVLink_message.__init__(self, MAVLink_command_long_message.id, MAVLink_command_long_message.name)
                self._fieldnames = MAVLink_command_long_message.fieldnames
                self._instance_field = MAVLink_command_long_message.instance_field
                self._instance_offset = MAVLink_command_long_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.command = command
                self.confirmation = confirmation
                self.param1 = param1
                self.param2 = param2
                self.param3 = param3
                self.param4 = param4
                self.param5 = param5
                self.param6 = param6
                self.param7 = param7

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 152, struct.pack('<fffffffHBBB', self.param1, self.param2, self.param3, self.param4, self.param5, self.param6, self.param7, self.command, self.target_system, self.target_component, self.confirmation), force_mavlink1=force_mavlink1)

class MAVLink_command_ack_message(MAVLink_message):
        '''
        Report status of a command. Includes feedback whether the
        command was executed. The command microservice is documented
        at https://mavlink.io/en/services/command.html
        '''
        id = MAVLINK_MSG_ID_COMMAND_ACK
        name = 'COMMAND_ACK'
        fieldnames = ['command', 'result']
        ordered_fieldnames = ['command', 'result']
        fieldtypes = ['uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"command": "MAV_CMD", "result": "MAV_RESULT"}
        fieldunits_by_name = {}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 143
        unpacker = '<HB'
        instance_field = None
        instance_offset = -1

        def __init__(self, command, result):
                MAVLink_message.__init__(self, MAVLink_command_ack_message.id, MAVLink_command_ack_message.name)
                self._fieldnames = MAVLink_command_ack_message.fieldnames
                self._instance_field = MAVLink_command_ack_message.instance_field
                self._instance_offset = MAVLink_command_ack_message.instance_offset
                self.command = command
                self.result = result

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 143, struct.pack('<HB', self.command, self.result), force_mavlink1=force_mavlink1)
                
class MAVLink_vfr_hud_message(MAVLink_message):
        '''
        Metrics typically displayed on a HUD for fixed wing aircraft.
        '''
        id = MAVLINK_MSG_ID_VFR_HUD
        name = 'VFR_HUD'
        fieldnames = ['airspeed', 'groundspeed', 'heading', 'throttle', 'alt', 'climb']
        ordered_fieldnames = ['airspeed', 'groundspeed', 'alt', 'climb', 'heading', 'throttle']
        fieldtypes = ['float', 'float', 'int16_t', 'uint16_t', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"airspeed": "m/s", "groundspeed": "m/s", "heading": "deg", "throttle": "%", "alt": "m", "climb": "m/s"}
        format = '<ffffhH'
        native_format = bytearray('<ffffhH', 'ascii')
        orders = [0, 1, 4, 5, 2, 3]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 20
        unpacker = '<ffffhH'
        instance_field = None
        instance_offset = -1

        def __init__(self, airspeed, groundspeed, heading, throttle, alt, climb):
                MAVLink_message.__init__(self, MAVLink_vfr_hud_message.id, MAVLink_vfr_hud_message.name)
                self._fieldnames = MAVLink_vfr_hud_message.fieldnames
                self._instance_field = MAVLink_vfr_hud_message.instance_field
                self._instance_offset = MAVLink_vfr_hud_message.instance_offset
                self.airspeed = airspeed
                self.groundspeed = groundspeed
                self.heading = heading
                self.throttle = throttle
                self.alt = alt
                self.climb = climb

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 20, struct.pack('<ffffhH', self.airspeed, self.groundspeed, self.alt, self.climb, self.heading, self.throttle), force_mavlink1=force_mavlink1)
                
class MAVLink_attitude_message(MAVLink_message):
        '''
        The attitude in the aeronautical frame (right-handed, Z-down,
        X-front, Y-right).
        '''
        id = MAVLINK_MSG_ID_ATTITUDE
        name = 'ATTITUDE'
        fieldnames = ['time_boot_ms', 'roll', 'pitch', 'yaw', 'rollspeed', 'pitchspeed', 'yawspeed']
        ordered_fieldnames = ['time_boot_ms', 'roll', 'pitch', 'yaw', 'rollspeed', 'pitchspeed', 'yawspeed']
        fieldtypes = ['uint32_t', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"time_boot_ms": "ms", "roll": "rad", "pitch": "rad", "yaw": "rad", "rollspeed": "rad/s", "pitchspeed": "rad/s", "yawspeed": "rad/s"}
        format = '<Iffffff'
        native_format = bytearray('<Iffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 39
        unpacker = '<Iffffff'
        instance_field = None
        instance_offset = -1

        def __init__(self, time_boot_ms, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed):
                MAVLink_message.__init__(self, MAVLink_attitude_message.id, MAVLink_attitude_message.name)
                self._fieldnames = MAVLink_attitude_message.fieldnames
                self._instance_field = MAVLink_attitude_message.instance_field
                self._instance_offset = MAVLink_attitude_message.instance_offset
                self.time_boot_ms = time_boot_ms
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.rollspeed = rollspeed
                self.pitchspeed = pitchspeed
                self.yawspeed = yawspeed

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 39, struct.pack('<Iffffff', self.time_boot_ms, self.roll, self.pitch, self.yaw, self.rollspeed, self.pitchspeed, self.yawspeed), force_mavlink1=force_mavlink1)
                
class MAVLink_scaled_imu_message(MAVLink_message):
        '''
        The RAW IMU readings for the usual 9DOF sensor setup. This
        message should contain the scaled values to the described
        units
        '''
        id = MAVLINK_MSG_ID_SCALED_IMU
        name = 'SCALED_IMU'
        fieldnames = ['time_boot_ms', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'xmag', 'ymag', 'zmag', 'temperature']
        ordered_fieldnames = ['time_boot_ms', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'xmag', 'ymag', 'zmag', 'temperature']
        fieldtypes = ['uint32_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"time_boot_ms": "ms", "xacc": "mG", "yacc": "mG", "zacc": "mG", "xgyro": "mrad/s", "ygyro": "mrad/s", "zgyro": "mrad/s", "xmag": "mgauss", "ymag": "mgauss", "zmag": "mgauss", "temperature": "cdegC"}
        format = '<Ihhhhhhhhhh'
        native_format = bytearray('<Ihhhhhhhhhh', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 170
        unpacker = '<Ihhhhhhhhhh'
        instance_field = None
        instance_offset = -1

        def __init__(self, time_boot_ms, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag, temperature=0):
                MAVLink_message.__init__(self, MAVLink_scaled_imu_message.id, MAVLink_scaled_imu_message.name)
                self._fieldnames = MAVLink_scaled_imu_message.fieldnames
                self._instance_field = MAVLink_scaled_imu_message.instance_field
                self._instance_offset = MAVLink_scaled_imu_message.instance_offset
                self.time_boot_ms = time_boot_ms
                self.xacc = xacc
                self.yacc = yacc
                self.zacc = zacc
                self.xgyro = xgyro
                self.ygyro = ygyro
                self.zgyro = zgyro
                self.xmag = xmag
                self.ymag = ymag
                self.zmag = zmag
                self.temperature = temperature

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 170, struct.pack('<Ihhhhhhhhhh', self.time_boot_ms, self.xacc, self.yacc, self.zacc, self.xgyro, self.ygyro, self.zgyro, self.xmag, self.ymag, self.zmag, self.temperature), force_mavlink1=force_mavlink1)
                
class MAVLink_gps_raw_int_message(MAVLink_message):
        '''
        The global position, as returned by the Global Positioning
        System (GPS). This is                 NOT the global position
        estimate of the system, but rather a RAW sensor value. See
        message GLOBAL_POSITION for the global position estimate.
        '''
        id = MAVLINK_MSG_ID_GPS_RAW_INT
        name = 'GPS_RAW_INT'
        fieldnames = ['time_usec', 'fix_type', 'lat', 'lon', 'alt', 'eph', 'epv', 'vel', 'cog', 'satellites_visible', 'alt_ellipsoid', 'h_acc', 'v_acc', 'vel_acc', 'hdg_acc', 'yaw']
        ordered_fieldnames = ['time_usec', 'lat', 'lon', 'alt', 'eph', 'epv', 'vel', 'cog', 'fix_type', 'satellites_visible', 'alt_ellipsoid', 'h_acc', 'v_acc', 'vel_acc', 'hdg_acc', 'yaw']
        fieldtypes = ['uint64_t', 'uint8_t', 'int32_t', 'int32_t', 'int32_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint8_t', 'int32_t', 'uint32_t', 'uint32_t', 'uint32_t', 'uint32_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"fix_type": "GPS_FIX_TYPE"}
        fieldunits_by_name = {"time_usec": "us", "lat": "degE7", "lon": "degE7", "alt": "mm", "vel": "cm/s", "cog": "cdeg", "alt_ellipsoid": "mm", "h_acc": "mm", "v_acc": "mm", "vel_acc": "mm", "hdg_acc": "degE5", "yaw": "cdeg"}
        format = '<QiiiHHHHBBiIIIIH'
        native_format = bytearray('<QiiiHHHHBBiIIIIH', 'ascii')
        orders = [0, 8, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 24
        unpacker = '<QiiiHHHHBBiIIIIH'
        instance_field = None
        instance_offset = -1

        def __init__(self, time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, alt_ellipsoid=0, h_acc=0, v_acc=0, vel_acc=0, hdg_acc=0, yaw=0):
                MAVLink_message.__init__(self, MAVLink_gps_raw_int_message.id, MAVLink_gps_raw_int_message.name)
                self._fieldnames = MAVLink_gps_raw_int_message.fieldnames
                self._instance_field = MAVLink_gps_raw_int_message.instance_field
                self._instance_offset = MAVLink_gps_raw_int_message.instance_offset
                self.time_usec = time_usec
                self.fix_type = fix_type
                self.lat = lat
                self.lon = lon
                self.alt = alt
                self.eph = eph
                self.epv = epv
                self.vel = vel
                self.cog = cog
                self.satellites_visible = satellites_visible
                self.alt_ellipsoid = alt_ellipsoid
                self.h_acc = h_acc
                self.v_acc = v_acc
                self.vel_acc = vel_acc
                self.hdg_acc = hdg_acc
                self.yaw = yaw

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 24, struct.pack('<QiiiHHHHBBiIIIIH', self.time_usec, self.lat, self.lon, self.alt, self.eph, self.epv, self.vel, self.cog, self.fix_type, self.satellites_visible, self.alt_ellipsoid, self.h_acc, self.v_acc, self.vel_acc, self.hdg_acc, self.yaw), force_mavlink1=force_mavlink1)
                
class MAVLink_ahrs_message(MAVLink_message):
        '''
        Status of DCM attitude estimator.
        '''
        id = MAVLINK_MSG_ID_AHRS
        name = 'AHRS'
        fieldnames = ['omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw']
        ordered_fieldnames = ['omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw']
        fieldtypes = ['float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"omegaIx": "rad/s", "omegaIy": "rad/s", "omegaIz": "rad/s"}
        format = '<fffffff'
        native_format = bytearray('<fffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 127
        unpacker = '<fffffff'
        instance_field = None
        instance_offset = -1

        def __init__(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                MAVLink_message.__init__(self, MAVLink_ahrs_message.id, MAVLink_ahrs_message.name)
                self._fieldnames = MAVLink_ahrs_message.fieldnames
                self._instance_field = MAVLink_ahrs_message.instance_field
                self._instance_offset = MAVLink_ahrs_message.instance_offset
                self.omegaIx = omegaIx
                self.omegaIy = omegaIy
                self.omegaIz = omegaIz
                self.accel_weight = accel_weight
                self.renorm_val = renorm_val
                self.error_rp = error_rp
                self.error_yaw = error_yaw

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 127, struct.pack('<fffffff', self.omegaIx, self.omegaIy, self.omegaIz, self.accel_weight, self.renorm_val, self.error_rp, self.error_yaw), force_mavlink1=force_mavlink1)
                
class MAVLink_data16_message(MAVLink_message):
        '''
        Data packet, size 16.
        '''
        id = MAVLINK_MSG_ID_DATA16
        name = 'DATA16'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB16B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 16]
        array_lengths = [0, 0, 16]
        crc_extra = 234
        unpacker = '<BB16B'
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data16_message.id, MAVLink_data16_message.name)
                self._fieldnames = MAVLink_data16_message.fieldnames
                self._instance_field = MAVLink_data16_message.instance_field
                self._instance_offset = MAVLink_data16_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 234, struct.pack('<BB16B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15]), force_mavlink1=force_mavlink1)

class MAVLink_data32_message(MAVLink_message):
        '''
        Data packet, size 32.
        '''
        id = MAVLINK_MSG_ID_DATA32
        name = 'DATA32'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB32B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 32]
        array_lengths = [0, 0, 32]
        crc_extra = 73
        unpacker = '<BB32B'
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data32_message.id, MAVLink_data32_message.name)
                self._fieldnames = MAVLink_data32_message.fieldnames
                self._instance_field = MAVLink_data32_message.instance_field
                self._instance_offset = MAVLink_data32_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 73, struct.pack('<BB32B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31]), force_mavlink1=force_mavlink1)

class MAVLink_data64_message(MAVLink_message):
        '''
        Data packet, size 64.
        '''
        id = MAVLINK_MSG_ID_DATA64
        name = 'DATA64'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB64B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 64]
        array_lengths = [0, 0, 64]
        crc_extra = 181
        unpacker = '<BB64B'
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data64_message.id, MAVLink_data64_message.name)
                self._fieldnames = MAVLink_data64_message.fieldnames
                self._instance_field = MAVLink_data64_message.instance_field
                self._instance_offset = MAVLink_data64_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 181, struct.pack('<BB64B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63]), force_mavlink1=force_mavlink1)

class MAVLink_data96_message(MAVLink_message):
        '''
        Data packet, size 96.
        '''
        id = MAVLINK_MSG_ID_DATA96
        name = 'DATA96'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB96B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 96]
        array_lengths = [0, 0, 96]
        crc_extra = 22
        unpacker = '<BB96B'
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data96_message.id, MAVLink_data96_message.name)
                self._fieldnames = MAVLink_data96_message.fieldnames
                self._instance_field = MAVLink_data96_message.instance_field
                self._instance_offset = MAVLink_data96_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<BB96B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63], self.data[64], self.data[65], self.data[66], self.data[67], self.data[68], self.data[69], self.data[70], self.data[71], self.data[72], self.data[73], self.data[74], self.data[75], self.data[76], self.data[77], self.data[78], self.data[79], self.data[80], self.data[81], self.data[82], self.data[83], self.data[84], self.data[85], self.data[86], self.data[87], self.data[88], self.data[89], self.data[90], self.data[91], self.data[92], self.data[93], self.data[94], self.data[95]), force_mavlink1=force_mavlink1)
                
class MAVLink_heartbeat_message(MAVLink_message):
        '''
        The heartbeat message shows that a system or component is
        present and responding. The type and autopilot fields (along
        with the message component id), allow the receiving system to
        treat further messages from this system appropriately (e.g. by
        laying out the user interface based on the autopilot). This
        microservice is documented at
        https://mavlink.io/en/services/heartbeat.html
        '''
        id = MAVLINK_MSG_ID_HEARTBEAT
        name = 'HEARTBEAT'
        fieldnames = ['type', 'autopilot', 'base_mode', 'custom_mode', 'system_status', 'mavlink_version']
        ordered_fieldnames = ['custom_mode', 'type', 'autopilot', 'base_mode', 'system_status', 'mavlink_version']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint32_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {"base_mode": "bitmask"}
        fieldenums_by_name = {"type": "MAV_TYPE", "autopilot": "MAV_AUTOPILOT", "base_mode": "MAV_MODE_FLAG", "system_status": "MAV_STATE"}
        fieldunits_by_name = {}
        format = '<IBBBBB'
        native_format = bytearray('<IBBBBB', 'ascii')
        orders = [1, 2, 3, 0, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 50
        unpacker = '<IBBBBB'
        instance_field = None
        instance_offset = -1

        def __init__(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version):
                MAVLink_message.__init__(self, MAVLink_heartbeat_message.id, MAVLink_heartbeat_message.name)
                self._fieldnames = MAVLink_heartbeat_message.fieldnames
                self._instance_field = MAVLink_heartbeat_message.instance_field
                self._instance_offset = MAVLink_heartbeat_message.instance_offset
                self.type = type
                self.autopilot = autopilot
                self.base_mode = base_mode
                self.custom_mode = custom_mode
                self.system_status = system_status
                self.mavlink_version = mavlink_version

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 50, struct.pack('<IBBBBB', self.custom_mode, self.type, self.autopilot, self.base_mode, self.system_status, self.mavlink_version), force_mavlink1=force_mavlink1)

class MAVLink_sys_status_message(MAVLink_message):
        '''
        The general system state. If the system is following the
        MAVLink standard, the system state is mainly defined by three
        orthogonal states/modes: The system mode, which is either
        LOCKED (motors shut down and locked), MANUAL (system under RC
        control), GUIDED (system with autonomous position control,
        position setpoint controlled manually) or AUTO (system guided
        by path/waypoint planner). The NAV_MODE defined the current
        flight state: LIFTOFF (often an open-loop maneuver), LANDING,
        WAYPOINTS or VECTOR. This represents the internal navigation
        state machine. The system status shows whether the system is
        currently active or not and if an emergency occurred. During
        the CRITICAL and EMERGENCY states the MAV is still considered
        to be active, but should start emergency procedures
        autonomously. After a failure occurred it should first move
        from active to critical to allow manual intervention and then
        move to emergency after a certain timeout.
        '''
        id = MAVLINK_MSG_ID_SYS_STATUS
        name = 'SYS_STATUS'
        fieldnames = ['onboard_control_sensors_present', 'onboard_control_sensors_enabled', 'onboard_control_sensors_health', 'load', 'voltage_battery', 'current_battery', 'battery_remaining', 'drop_rate_comm', 'errors_comm', 'errors_count1', 'errors_count2', 'errors_count3', 'errors_count4']
        ordered_fieldnames = ['onboard_control_sensors_present', 'onboard_control_sensors_enabled', 'onboard_control_sensors_health', 'load', 'voltage_battery', 'current_battery', 'drop_rate_comm', 'errors_comm', 'errors_count1', 'errors_count2', 'errors_count3', 'errors_count4', 'battery_remaining']
        fieldtypes = ['uint32_t', 'uint32_t', 'uint32_t', 'uint16_t', 'uint16_t', 'int16_t', 'int8_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t']
        fielddisplays_by_name = {"onboard_control_sensors_present": "bitmask", "onboard_control_sensors_enabled": "bitmask", "onboard_control_sensors_health": "bitmask"}
        fieldenums_by_name = {"onboard_control_sensors_present": "MAV_SYS_STATUS_SENSOR", "onboard_control_sensors_enabled": "MAV_SYS_STATUS_SENSOR", "onboard_control_sensors_health": "MAV_SYS_STATUS_SENSOR"}
        fieldunits_by_name = {"load": "d%", "voltage_battery": "mV", "current_battery": "cA", "battery_remaining": "%", "drop_rate_comm": "c%"}
        format = '<IIIHHhHHHHHHb'
        native_format = bytearray('<IIIHHhHHHHHHb', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 12, 6, 7, 8, 9, 10, 11]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 124
        unpacker = '<IIIHHhHHHHHHb'
        instance_field = None
        instance_offset = -1

        def __init__(self, onboard_control_sensors_present, onboard_control_sensors_enabled, onboard_control_sensors_health, load, voltage_battery, current_battery, battery_remaining, drop_rate_comm, errors_comm, errors_count1, errors_count2, errors_count3, errors_count4):
                MAVLink_message.__init__(self, MAVLink_sys_status_message.id, MAVLink_sys_status_message.name)
                self._fieldnames = MAVLink_sys_status_message.fieldnames
                self._instance_field = MAVLink_sys_status_message.instance_field
                self._instance_offset = MAVLink_sys_status_message.instance_offset
                self.onboard_control_sensors_present = onboard_control_sensors_present
                self.onboard_control_sensors_enabled = onboard_control_sensors_enabled
                self.onboard_control_sensors_health = onboard_control_sensors_health
                self.load = load
                self.voltage_battery = voltage_battery
                self.current_battery = current_battery
                self.battery_remaining = battery_remaining
                self.drop_rate_comm = drop_rate_comm
                self.errors_comm = errors_comm
                self.errors_count1 = errors_count1
                self.errors_count2 = errors_count2
                self.errors_count3 = errors_count3
                self.errors_count4 = errors_count4

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 124, struct.pack('<IIIHHhHHHHHHb', self.onboard_control_sensors_present, self.onboard_control_sensors_enabled, self.onboard_control_sensors_health, self.load, self.voltage_battery, self.current_battery, self.drop_rate_comm, self.errors_comm, self.errors_count1, self.errors_count2, self.errors_count3, self.errors_count4, self.battery_remaining), force_mavlink1=force_mavlink1)

class MAVLink_system_time_message(MAVLink_message):
        '''
        The system time is the time of the master clock, typically the
        computer clock of the main onboard computer.
        '''
        id = MAVLINK_MSG_ID_SYSTEM_TIME
        name = 'SYSTEM_TIME'
        fieldnames = ['time_unix_usec', 'time_boot_ms']
        ordered_fieldnames = ['time_unix_usec', 'time_boot_ms']
        fieldtypes = ['uint64_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"time_unix_usec": "us", "time_boot_ms": "ms"}
        format = '<QI'
        native_format = bytearray('<QI', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 137
        unpacker = '<QI'
        instance_field = None
        instance_offset = -1

        def __init__(self, time_unix_usec, time_boot_ms):
                MAVLink_message.__init__(self, MAVLink_system_time_message.id, MAVLink_system_time_message.name)
                self._fieldnames = MAVLink_system_time_message.fieldnames
                self._instance_field = MAVLink_system_time_message.instance_field
                self._instance_offset = MAVLink_system_time_message.instance_offset
                self.time_unix_usec = time_unix_usec
                self.time_boot_ms = time_boot_ms

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 137, struct.pack('<QI', self.time_unix_usec, self.time_boot_ms), force_mavlink1=force_mavlink1)

mavlink_map = {
        MAVLINK_MSG_ID_AHRS : MAVLink_ahrs_message,
        MAVLINK_MSG_ID_DATA16 : MAVLink_data16_message,
        MAVLINK_MSG_ID_DATA32 : MAVLink_data32_message,
        MAVLINK_MSG_ID_DATA64 : MAVLink_data64_message,
        MAVLINK_MSG_ID_DATA96 : MAVLink_data96_message,
        MAVLINK_MSG_ID_HEARTBEAT : MAVLink_heartbeat_message,
        MAVLINK_MSG_ID_SYS_STATUS : MAVLink_sys_status_message,
        MAVLINK_MSG_ID_SYSTEM_TIME : MAVLink_system_time_message,
        MAVLINK_MSG_ID_GPS_RAW_INT : MAVLink_gps_raw_int_message,
        MAVLINK_MSG_ID_SCALED_IMU : MAVLink_scaled_imu_message,
        MAVLINK_MSG_ID_ATTITUDE : MAVLink_attitude_message,
        MAVLINK_MSG_ID_VFR_HUD : MAVLink_vfr_hud_message,
        MAVLINK_MSG_ID_COMMAND_INT : MAVLink_command_int_message,
        MAVLINK_MSG_ID_COMMAND_LONG : MAVLink_command_long_message,
        MAVLINK_MSG_ID_COMMAND_ACK : MAVLink_command_ack_message,
        MAVLINK_MSG_ID_NAMED_VALUE_FLOAT : MAVLink_named_value_float_message,
        MAVLINK_MSG_ID_NAMED_VALUE_INT : MAVLink_named_value_int_message,
        MAVLINK_MSG_ID_STATUSTEXT : MAVLink_statustext_message,
}

# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}

enums = {}

# MAV_TYPE
enums['MAV_TYPE'] = {}
MAV_TYPE_GENERIC = 0 # Generic micro air vehicle
enums['MAV_TYPE'][0] = EnumEntry('MAV_TYPE_GENERIC', '''Generic micro air vehicle''')
MAV_TYPE_FIXED_WING = 1 # Fixed wing aircraft.
enums['MAV_TYPE'][1] = EnumEntry('MAV_TYPE_FIXED_WING', '''Fixed wing aircraft.''')
MAV_TYPE_QUADROTOR = 2 # Quadrotor
enums['MAV_TYPE'][2] = EnumEntry('MAV_TYPE_QUADROTOR', '''Quadrotor''')
MAV_TYPE_COAXIAL = 3 # Coaxial helicopter
enums['MAV_TYPE'][3] = EnumEntry('MAV_TYPE_COAXIAL', '''Coaxial helicopter''')
MAV_TYPE_HELICOPTER = 4 # Normal helicopter with tail rotor.
enums['MAV_TYPE'][4] = EnumEntry('MAV_TYPE_HELICOPTER', '''Normal helicopter with tail rotor.''')
MAV_TYPE_ANTENNA_TRACKER = 5 # Ground installation
enums['MAV_TYPE'][5] = EnumEntry('MAV_TYPE_ANTENNA_TRACKER', '''Ground installation''')
MAV_TYPE_GCS = 6 # Operator control unit / ground control station
enums['MAV_TYPE'][6] = EnumEntry('MAV_TYPE_GCS', '''Operator control unit / ground control station''')
MAV_TYPE_AIRSHIP = 7 # Airship, controlled
enums['MAV_TYPE'][7] = EnumEntry('MAV_TYPE_AIRSHIP', '''Airship, controlled''')
MAV_TYPE_FREE_BALLOON = 8 # Free balloon, uncontrolled
enums['MAV_TYPE'][8] = EnumEntry('MAV_TYPE_FREE_BALLOON', '''Free balloon, uncontrolled''')
MAV_TYPE_ROCKET = 9 # Rocket
enums['MAV_TYPE'][9] = EnumEntry('MAV_TYPE_ROCKET', '''Rocket''')
MAV_TYPE_GROUND_ROVER = 10 # Ground rover
enums['MAV_TYPE'][10] = EnumEntry('MAV_TYPE_GROUND_ROVER', '''Ground rover''')
MAV_TYPE_SURFACE_BOAT = 11 # Surface vessel, boat, ship
enums['MAV_TYPE'][11] = EnumEntry('MAV_TYPE_SURFACE_BOAT', '''Surface vessel, boat, ship''')
MAV_TYPE_SUBMARINE = 12 # Submarine
enums['MAV_TYPE'][12] = EnumEntry('MAV_TYPE_SUBMARINE', '''Submarine''')
MAV_TYPE_HEXAROTOR = 13 # Hexarotor
enums['MAV_TYPE'][13] = EnumEntry('MAV_TYPE_HEXAROTOR', '''Hexarotor''')
MAV_TYPE_OCTOROTOR = 14 # Octorotor
enums['MAV_TYPE'][14] = EnumEntry('MAV_TYPE_OCTOROTOR', '''Octorotor''')
MAV_TYPE_TRICOPTER = 15 # Tricopter
enums['MAV_TYPE'][15] = EnumEntry('MAV_TYPE_TRICOPTER', '''Tricopter''')
MAV_TYPE_FLAPPING_WING = 16 # Flapping wing
enums['MAV_TYPE'][16] = EnumEntry('MAV_TYPE_FLAPPING_WING', '''Flapping wing''')
MAV_TYPE_KITE = 17 # Kite
enums['MAV_TYPE'][17] = EnumEntry('MAV_TYPE_KITE', '''Kite''')
MAV_TYPE_ONBOARD_CONTROLLER = 18 # Onboard companion controller
enums['MAV_TYPE'][18] = EnumEntry('MAV_TYPE_ONBOARD_CONTROLLER', '''Onboard companion controller''')
MAV_TYPE_VTOL_DUOROTOR = 19 # Two-rotor VTOL using control surfaces in vertical operation in
                        # addition. Tailsitter.
enums['MAV_TYPE'][19] = EnumEntry('MAV_TYPE_VTOL_DUOROTOR', '''Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.''')
MAV_TYPE_VTOL_QUADROTOR = 20 # Quad-rotor VTOL using a V-shaped quad config in vertical operation.
                        # Tailsitter.
enums['MAV_TYPE'][20] = EnumEntry('MAV_TYPE_VTOL_QUADROTOR', '''Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.''')
MAV_TYPE_VTOL_TILTROTOR = 21 # Tiltrotor VTOL
enums['MAV_TYPE'][21] = EnumEntry('MAV_TYPE_VTOL_TILTROTOR', '''Tiltrotor VTOL''')
MAV_TYPE_VTOL_RESERVED2 = 22 # VTOL reserved 2
enums['MAV_TYPE'][22] = EnumEntry('MAV_TYPE_VTOL_RESERVED2', '''VTOL reserved 2''')
MAV_TYPE_VTOL_RESERVED3 = 23 # VTOL reserved 3
enums['MAV_TYPE'][23] = EnumEntry('MAV_TYPE_VTOL_RESERVED3', '''VTOL reserved 3''')
MAV_TYPE_VTOL_RESERVED4 = 24 # VTOL reserved 4
enums['MAV_TYPE'][24] = EnumEntry('MAV_TYPE_VTOL_RESERVED4', '''VTOL reserved 4''')
MAV_TYPE_VTOL_RESERVED5 = 25 # VTOL reserved 5
enums['MAV_TYPE'][25] = EnumEntry('MAV_TYPE_VTOL_RESERVED5', '''VTOL reserved 5''')
MAV_TYPE_GIMBAL = 26 # Gimbal
enums['MAV_TYPE'][26] = EnumEntry('MAV_TYPE_GIMBAL', '''Gimbal''')
MAV_TYPE_ADSB = 27 # ADSB system
enums['MAV_TYPE'][27] = EnumEntry('MAV_TYPE_ADSB', '''ADSB system''')
MAV_TYPE_PARAFOIL = 28 # Steerable, nonrigid airfoil
enums['MAV_TYPE'][28] = EnumEntry('MAV_TYPE_PARAFOIL', '''Steerable, nonrigid airfoil''')
MAV_TYPE_DODECAROTOR = 29 # Dodecarotor
enums['MAV_TYPE'][29] = EnumEntry('MAV_TYPE_DODECAROTOR', '''Dodecarotor''')
MAV_TYPE_CAMERA = 30 # Camera
enums['MAV_TYPE'][30] = EnumEntry('MAV_TYPE_CAMERA', '''Camera''')
MAV_TYPE_CHARGING_STATION = 31 # Charging station
enums['MAV_TYPE'][31] = EnumEntry('MAV_TYPE_CHARGING_STATION', '''Charging station''')
MAV_TYPE_FLARM = 32 # FLARM collision avoidance system
enums['MAV_TYPE'][32] = EnumEntry('MAV_TYPE_FLARM', '''FLARM collision avoidance system''')
MAV_TYPE_SERVO = 33 # Servo
enums['MAV_TYPE'][33] = EnumEntry('MAV_TYPE_SERVO', '''Servo''')
MAV_TYPE_ODID = 34 # Open Drone ID. See https://mavlink.io/en/services/opendroneid.html.
enums['MAV_TYPE'][34] = EnumEntry('MAV_TYPE_ODID', '''Open Drone ID. See https://mavlink.io/en/services/opendroneid.html.''')
MAV_TYPE_DECAROTOR = 35 # Decarotor
enums['MAV_TYPE'][35] = EnumEntry('MAV_TYPE_DECAROTOR', '''Decarotor''')
MAV_TYPE_ENUM_END = 36 # 
enums['MAV_TYPE'][36] = EnumEntry('MAV_TYPE_ENUM_END', '''''')

